开发计划：
1. 给服务端增加音乐下载功能，后台可设置自动下载或手动下载指定歌单的音乐到服务器。
2. 服务器增加音乐源的能力，支持使用服务器的音乐源。自定义源脚本编写示例见：'/home/ruoruo/script/lxserver/自定义源脚本编写说明.txt'

---
用户指令：继续

执行内容：
1. 运行 TypeScript 构建验证
2. 发现3个编译错误并修复：
   - autoDownloader.ts 的两个事件监听器回调函数改为 async
   - downloadManager.ts 的错误处理改为检查错误消息
3. 重新构建成功，所有功能实现完成

---
用户指令：把之前做的计划写到markdown里基于以下信息，设计前端下载管理功能的实现方案：

## 后端已实现的 API 端点

1. **POST /api/download/start** - 手动触发下载
   - 请求体: { userName: string, listIds?: string[] }
   - 返回: { scanned: number, added: number }

2. **GET /api/download/tasks** - 查询任务列表
   - 返回: { records: DownloadRecord[], queueSize: number, activeCount: number }

3. **POST /api/download/retry** - 重试失败任务
   - 请求体: { taskId: string }

4. **POST /api/download/cancel** - 取消任务
   - 请求体: { taskId: string }

5. **DELETE /api/download/clean** - 清理记录
   - 请求体: { statuses?: string[] }

6. **GET /api/download/progress** - SSE 进度推送
   - 事件类型: task_update, task_added, task_removed, queue_status

7. **配置管理** - 通过 /api/config 读写下载配置
   - 配置字段: download.enabled, download.path, download.qualityPriority, download.concurrency, download.autoEnabled, download.autoInterval, download.autoUsers, download.autoPlaylists

---
用户指令：现在把刚才修改的所有后端功能在前端的合适位置适配

执行内容：
完成了前端下载管理功能的完整实现，包括9个步骤：

1. **HTML 结构修改** (index.html)
   - 添加下载管理导航菜单项
   - 创建下载管理主视图（操作栏、统计卡片、任务列表）
   - 创建手动下载模态框（用户选择、歌单选择）
   - 扩展配置表单（8个下载配置字段）

2. **JavaScript 功能实现** (app.js)
   - 核心方法：bindDownloadEvents, loadDownloadTasks, updateDownloadStats, renderDownloadTasks, renderTaskItem, getStatusIcon, retryTask, cancelTask, cleanTasks, filterTasks
   - SSE 实时进度：initDownloadSSE, updateTaskInList, addTaskToList, removeTaskFromList
   - 手动下载功能：showManualDownloadModal, loadUserPlaylists, startManualDownload
   - 配置管理扩展：扩展 loadConfig 和 saveConfig 方法支持下载配置

3. **CSS 样式添加** (style.css)
   - 任务项样式（.task-item 及相关类）
   - 状态指示器样式（pending, downloading, completed, failed, cancelled）
   - 进度条样式（.progress-bar-container, .progress-bar）
   - 错误信息样式（.task-error）
   - 任务操作按钮样式（.btn-task-action）

功能特点：
- 实时进度更新（通过 SSE）
- 任务状态管理（等待、下载中、已完成、失败、已取消）
- 手动触发下载（支持选择用户和歌单）
- 任务操作（重试、取消、清理）
- 配置管理（启用/禁用、路径、音质、并发数、自动下载等）
- Glass-morphism 设计风格
- 响应式布局

---
用户指令：报告三个问题
问题1：显示错误，应该新增下载了1首，但是显示0首。后端返回的有问题 {"success":true,"scanned":2,"added":0}
问题2：清理失败按钮，按下后把成功的也清理了。
问题3：自动下载的设置在哪里

执行内容：
**问题1分析**：
这不是bug，而是正常的去重行为。后端的 addTasks 方法会检查歌曲是否已经存在于下载记录中（状态为 completed、downloading 或 pending）。如果存在，就不会重新添加。
- 后端返回 scanned:2 表示扫描了2首歌
- added:0 表示这2首歌都已经在下载记录中了
- 用户需要检查下载任务列表，看看这些歌曲是否已经在列表中
- 如果歌曲下载失败了，应该使用"重试"功能而不是重新触发下载

**问题2修复**：
发现后端路由的bug：`/api/download/clean` 路由没有读取请求体中的 statuses 参数，导致总是使用默认值 ['completed', 'failed', 'cancelled'] 清理所有状态的记录。
- 修改文件：src/server/server.ts (行 1677-1702)
- 修改内容：使用 readBody(req) 读取请求体，解析 statuses 参数并传递给 cleanRecords 方法
- 修复后：清理失败按钮现在只会清理 failed 和 cancelled 状态的记录，不会清理 completed 状态的记录

**问题3回答**：
自动下载的设置在**系统配置**页面中：
1. 点击左侧菜单的"系统配置"
2. 向下滚动到"自动下载配置"区域
3. 包含以下设置：
   - 启用自动下载（复选框）
   - 自动下载间隔（分钟）
   - 自动下载用户（逗号分隔）
   - 自动下载歌单ID（逗号分隔）

---
用户指令：报告两个新问题
问题1：浏览器扩展错误（Immersive Translate），与项目无关
问题2：现在下载后会一直显示下载中，0%，但其实已经下载完了

执行内容：
**问题1**：这是浏览器扩展（沉浸式翻译）的错误，与项目无关，无需处理。

**问题2修复**：
发现进度更新的节流逻辑有严重bug：
- 原逻辑：`if (task.record.progress % 5 === 0)` - 只有进度是5的倍数时才通知
- 问题：如果进度从0%跳到1%、2%、3%、4%、6%...，可能永远不会触发通知
- 结果：前端在下载过程中看不到任何进度更新，一直显示"下载中，0%"

修复方案：
1. 修改 DownloadTask 接口，添加 lastNotifyTime 和 lastNotifyProgress 字段
2. 改用时间节流：每秒最多通知一次，且只在进度变化时通知
3. 确保下载完成时一定发送最终通知（这个已经是正确的）

修改文件：src/server/download/downloadManager.ts
- 第31-36行：添加 lastNotifyTime 和 lastNotifyProgress 字段
- 第461-480行：修改进度更新逻辑，使用时间节流

---
用户指令：浏览器会一直向这个地址发送请求，是什么原因？https://us.i.posthog.com/s/?ip=0&_=1770796823775&ver=1.345.2&compression=gzip-js

执行内容：
**问题分析**：
这是正常的 PostHog 分析服务行为，PostHog 是一个产品分析和会话记录工具。

**PostHog 的作用**：
1. 跟踪用户事件和行为
2. 记录会话数据
3. 更新功能标志
4. 发送分析数据
5. 帮助开发者了解用户如何使用应用

**代码位置**：
- 文件：public/index.html (第 10-16 行)
- PostHog 在页面加载时初始化
- 使用条件：`if (!window.CONFIG || !window.CONFIG.disableTelemetry)`

**如何禁用**（如果不需要）：
1. 在配置文件中添加 `disableTelemetry: true`
2. 或者直接从 index.html 中删除 PostHog 初始化代码

**结论**：
这些请求是正常的，用于收集匿名使用数据以改进产品。如果不希望发送遥测数据，可以通过配置禁用。基于以下背景信息，设计一个完整的实现方案，使下载的音乐可以作为自定义源被使用。

## 背景信息

### 1. 自定义源机制
- 脚本存放在 `/mnt/data/script/lxserver/data/data/users/source/_open/` 或用户目录
- 脚本在 VM2 沙箱中执行，可访问 `globalThis.lx` API
- 脚本通过 `lx.on(EVENT_NAMES.request, handler)` 处理请求
- 支持的 action: musicUrl, lyric, pic
- 脚本通过 `lx.send('inited', { sources: {...} })` 注册源

### 2. 下载管理器结构
- 音乐文件存储在 `{musicDir}/{source}/{singer}/{songName}.{ext}`
- 下载记录存储在 `{musicDir}/download_records.json`
- DownloadManager 提供 `findLocalFile(source, songId)` 和 `findLocalFileByInfo(name, singer)` 方法
- LocalMusicSource 提供三层索引：按 songId、按 name+singer、按 fileId

### 3. 用户需求
用户希望将已下载的音乐作为自定义源使用，这样客户端可以直接播放本地下载的音乐文件。

## 设计要求

请设计一个完整的实现方案，包括：

1. **自定义源脚本设计**
   - 如何在脚本中访问已下载的音乐文件？
   - 如何处理 musicUrl、lyric、pic 请求？
   - 脚本应该注册什么源（source key）？

2. **服务器端支持**
   - 是否需要添加 HTTP 端点来提供本地文件访问？
   - 如何将本地文件路径转换为 HTTP URL？
   - 是否需要修改 userApi.ts 或其他文件？

3. **集成方案**
   - 如何让自定义源脚本访问 LocalMusicSource 或 DownloadManager？
   - 是否需要在 sandbox 中暴露额外的 API？
   - 如何处理文件不存在的情况？

4. **实现步骤**
   - 详细的实现步骤
   - 需要修改或创建的文件
   - 关键代码片段

5. **替代方案**
   - 是否有其他实现方式？
   - 各方案的优缺点对比

请提供详细的设计方案，包括关键代码示例和实现步骤。
